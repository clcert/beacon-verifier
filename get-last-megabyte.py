# Retrieve the last 15625 output values generated by the beacon (1 MB)
import requests
import json
import sys
from tqdm import tqdm


CLCERT_BEACON_URL = "https://random.uchile.cl/"
PULSE_PREFIX = "beacon/2.0/"
requests.packages.urllib3.disable_warnings()  # Disable warning for self signed certificate


class BeaconServerError(Exception):
    def __init__(self):
        pass


class BeaconPulseError(Exception):
    def __init__(self):
        pass


def get_json(url, retry=0):
    # time.sleep(0.05)  # Prevent 'Too Many Requests' response from server

    if retry == 5:
        raise BeaconServerError

    try:
        req = requests.get(url)
    except ConnectionError:
        raise BeaconServerError

    req_code = req.status_code

    if req_code == 200:  # success
        return json.loads(req.content)

    if req_code == 500 and retry < 5:  # retry if a 500 response is returned (up to 5 times)
        return get_json(url, retry=retry + 1)

    if req_code == 502:  # upstream server is down
        raise BeaconServerError

    if req_code == 404:  # record not found
        raise BeaconPulseError


# GET ID OF LAST PULSE
try:
    lp = get_json(CLCERT_BEACON_URL + PULSE_PREFIX + "pulse/last")["pulse"]
except (BeaconServerError, BeaconPulseError):
    print("BEACON SERVER IS DOWN")
    sys.exit()
last_pulse_id = lp["pulseIndex"]
last_chain_id = lp["chainIndex"]

i = last_pulse_id
c = 0
while c < 15625:  # retrieve 1 MB of data
    pulse = get_json(CLCERT_BEACON_URL + PULSE_PREFIX + "chain/" + str(last_chain_id) + "/pulse/" + str(last_pulse_id))["pulse"]
    if pulse["statusCode"] == 0:
        output_value = pulse["outputValue"]
        with open('last_pulses_0.bin', 'ba') as f:
            f.write(bytes.fromhex(output_value))
            f.close()
        c += 1
    i -= 1
    if c % 1000 == 0:
        print('pulses downloaded: ' + str(c))
